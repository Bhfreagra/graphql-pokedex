module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregatePokemon {
  count: Int!
}

type AggregatePokemonType {
  count: Int!
}

type AggregateType {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createPokemon(data: PokemonCreateInput!): Pokemon!
  updatePokemon(data: PokemonUpdateInput!, where: PokemonWhereUniqueInput!): Pokemon
  updateManyPokemons(data: PokemonUpdateManyMutationInput!, where: PokemonWhereInput): BatchPayload!
  upsertPokemon(where: PokemonWhereUniqueInput!, create: PokemonCreateInput!, update: PokemonUpdateInput!): Pokemon!
  deletePokemon(where: PokemonWhereUniqueInput!): Pokemon
  deleteManyPokemons(where: PokemonWhereInput): BatchPayload!
  createPokemonType(data: PokemonTypeCreateInput!): PokemonType!
  updatePokemonType(data: PokemonTypeUpdateInput!, where: PokemonTypeWhereUniqueInput!): PokemonType
  updateManyPokemonTypes(data: PokemonTypeUpdateManyMutationInput!, where: PokemonTypeWhereInput): BatchPayload!
  upsertPokemonType(where: PokemonTypeWhereUniqueInput!, create: PokemonTypeCreateInput!, update: PokemonTypeUpdateInput!): PokemonType!
  deletePokemonType(where: PokemonTypeWhereUniqueInput!): PokemonType
  deleteManyPokemonTypes(where: PokemonTypeWhereInput): BatchPayload!
  createType(data: TypeCreateInput!): Type!
  updateType(data: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type
  updateManyTypes(data: TypeUpdateManyMutationInput!, where: TypeWhereInput): BatchPayload!
  upsertType(where: TypeWhereUniqueInput!, create: TypeCreateInput!, update: TypeUpdateInput!): Type!
  deleteType(where: TypeWhereUniqueInput!): Type
  deleteManyTypes(where: TypeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pokemon {
  id: ID!
  name: String!
  order: Int!
  sprite: String!
  createdAt: DateTime!
  types(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonType!]
}

type PokemonConnection {
  pageInfo: PageInfo!
  edges: [PokemonEdge]!
  aggregate: AggregatePokemon!
}

input PokemonCreateInput {
  id: ID
  name: String!
  order: Int!
  sprite: String!
  types: PokemonTypeCreateManyInput
}

type PokemonEdge {
  node: Pokemon!
  cursor: String!
}

enum PokemonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
  sprite_ASC
  sprite_DESC
  createdAt_ASC
  createdAt_DESC
}

type PokemonPreviousValues {
  id: ID!
  name: String!
  order: Int!
  sprite: String!
  createdAt: DateTime!
}

type PokemonSubscriptionPayload {
  mutation: MutationType!
  node: Pokemon
  updatedFields: [String!]
  previousValues: PokemonPreviousValues
}

input PokemonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonWhereInput
  AND: [PokemonSubscriptionWhereInput!]
  OR: [PokemonSubscriptionWhereInput!]
  NOT: [PokemonSubscriptionWhereInput!]
}

type PokemonType {
  _id: ID!
  slot: Int!
  type: Type!
}

type PokemonTypeConnection {
  pageInfo: PageInfo!
  edges: [PokemonTypeEdge]!
  aggregate: AggregatePokemonType!
}

input PokemonTypeCreateInput {
  _id: ID
  slot: Int!
  type: TypeCreateOneInput!
}

input PokemonTypeCreateManyInput {
  create: [PokemonTypeCreateInput!]
  connect: [PokemonTypeWhereUniqueInput!]
}

type PokemonTypeEdge {
  node: PokemonType!
  cursor: String!
}

enum PokemonTypeOrderByInput {
  _id_ASC
  _id_DESC
  slot_ASC
  slot_DESC
}

type PokemonTypePreviousValues {
  _id: ID!
  slot: Int!
}

input PokemonTypeScalarWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  slot: Int
  slot_not: Int
  slot_in: [Int!]
  slot_not_in: [Int!]
  slot_lt: Int
  slot_lte: Int
  slot_gt: Int
  slot_gte: Int
  AND: [PokemonTypeScalarWhereInput!]
  OR: [PokemonTypeScalarWhereInput!]
  NOT: [PokemonTypeScalarWhereInput!]
}

enum PokemonTypesListInput {
  Normal
  Fire
  Water
  Grass
  Electric
  Ice
  Fighting
  Poison
  Ground
  Flying
  Psychic
  Bug
  Rock
  Ghost
  Dark
  Dragon
  Steel
  Fairy
}

type PokemonTypeSubscriptionPayload {
  mutation: MutationType!
  node: PokemonType
  updatedFields: [String!]
  previousValues: PokemonTypePreviousValues
}

input PokemonTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonTypeWhereInput
  AND: [PokemonTypeSubscriptionWhereInput!]
  OR: [PokemonTypeSubscriptionWhereInput!]
  NOT: [PokemonTypeSubscriptionWhereInput!]
}

input PokemonTypeUpdateDataInput {
  slot: Int
  type: TypeUpdateOneRequiredInput
}

input PokemonTypeUpdateInput {
  slot: Int
  type: TypeUpdateOneRequiredInput
}

input PokemonTypeUpdateManyDataInput {
  slot: Int
}

input PokemonTypeUpdateManyInput {
  create: [PokemonTypeCreateInput!]
  update: [PokemonTypeUpdateWithWhereUniqueNestedInput!]
  upsert: [PokemonTypeUpsertWithWhereUniqueNestedInput!]
  delete: [PokemonTypeWhereUniqueInput!]
  connect: [PokemonTypeWhereUniqueInput!]
  set: [PokemonTypeWhereUniqueInput!]
  disconnect: [PokemonTypeWhereUniqueInput!]
  deleteMany: [PokemonTypeScalarWhereInput!]
  updateMany: [PokemonTypeUpdateManyWithWhereNestedInput!]
}

input PokemonTypeUpdateManyMutationInput {
  slot: Int
}

input PokemonTypeUpdateManyWithWhereNestedInput {
  where: PokemonTypeScalarWhereInput!
  data: PokemonTypeUpdateManyDataInput!
}

input PokemonTypeUpdateWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput!
  data: PokemonTypeUpdateDataInput!
}

input PokemonTypeUpsertWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput!
  update: PokemonTypeUpdateDataInput!
  create: PokemonTypeCreateInput!
}

input PokemonTypeWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  slot: Int
  slot_not: Int
  slot_in: [Int!]
  slot_not_in: [Int!]
  slot_lt: Int
  slot_lte: Int
  slot_gt: Int
  slot_gte: Int
  type: TypeWhereInput
  AND: [PokemonTypeWhereInput!]
  OR: [PokemonTypeWhereInput!]
  NOT: [PokemonTypeWhereInput!]
}

input PokemonTypeWhereUniqueInput {
  _id: ID
}

input PokemonUpdateInput {
  name: String
  order: Int
  sprite: String
  types: PokemonTypeUpdateManyInput
}

input PokemonUpdateManyMutationInput {
  name: String
  order: Int
  sprite: String
}

input PokemonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  sprite: String
  sprite_not: String
  sprite_in: [String!]
  sprite_not_in: [String!]
  sprite_lt: String
  sprite_lte: String
  sprite_gt: String
  sprite_gte: String
  sprite_contains: String
  sprite_not_contains: String
  sprite_starts_with: String
  sprite_not_starts_with: String
  sprite_ends_with: String
  sprite_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  types_every: PokemonTypeWhereInput
  types_some: PokemonTypeWhereInput
  types_none: PokemonTypeWhereInput
  AND: [PokemonWhereInput!]
  OR: [PokemonWhereInput!]
  NOT: [PokemonWhereInput!]
}

input PokemonWhereUniqueInput {
  id: ID
  name: String
}

type Query {
  pokemon(where: PokemonWhereUniqueInput!): Pokemon
  pokemons(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pokemon]!
  pokemonsConnection(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonConnection!
  pokemonType(where: PokemonTypeWhereUniqueInput!): PokemonType
  pokemonTypes(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonType]!
  pokemonTypesConnection(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonTypeConnection!
  type(where: TypeWhereUniqueInput!): Type
  types(where: TypeWhereInput, orderBy: TypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Type]!
  typesConnection(where: TypeWhereInput, orderBy: TypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TypeConnection!
  node(id: ID!): Node
}

type Subscription {
  pokemon(where: PokemonSubscriptionWhereInput): PokemonSubscriptionPayload
  pokemonType(where: PokemonTypeSubscriptionWhereInput): PokemonTypeSubscriptionPayload
  type(where: TypeSubscriptionWhereInput): TypeSubscriptionPayload
}

type Type {
  id: ID!
  name: PokemonTypesListInput!
  url: String!
  createdAt: DateTime!
}

type TypeConnection {
  pageInfo: PageInfo!
  edges: [TypeEdge]!
  aggregate: AggregateType!
}

input TypeCreateInput {
  id: ID
  name: PokemonTypesListInput!
  url: String!
}

input TypeCreateOneInput {
  create: TypeCreateInput
  connect: TypeWhereUniqueInput
}

type TypeEdge {
  node: Type!
  cursor: String!
}

enum TypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
}

type TypePreviousValues {
  id: ID!
  name: PokemonTypesListInput!
  url: String!
  createdAt: DateTime!
}

type TypeSubscriptionPayload {
  mutation: MutationType!
  node: Type
  updatedFields: [String!]
  previousValues: TypePreviousValues
}

input TypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TypeWhereInput
  AND: [TypeSubscriptionWhereInput!]
  OR: [TypeSubscriptionWhereInput!]
  NOT: [TypeSubscriptionWhereInput!]
}

input TypeUpdateDataInput {
  name: PokemonTypesListInput
  url: String
}

input TypeUpdateInput {
  name: PokemonTypesListInput
  url: String
}

input TypeUpdateManyMutationInput {
  name: PokemonTypesListInput
  url: String
}

input TypeUpdateOneRequiredInput {
  create: TypeCreateInput
  update: TypeUpdateDataInput
  upsert: TypeUpsertNestedInput
  connect: TypeWhereUniqueInput
}

input TypeUpsertNestedInput {
  update: TypeUpdateDataInput!
  create: TypeCreateInput!
}

input TypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: PokemonTypesListInput
  name_not: PokemonTypesListInput
  name_in: [PokemonTypesListInput!]
  name_not_in: [PokemonTypesListInput!]
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [TypeWhereInput!]
  OR: [TypeWhereInput!]
  NOT: [TypeWhereInput!]
}

input TypeWhereUniqueInput {
  id: ID
}
`
      }
    